以下のゲームを作りたいです

- 食べ物の画像 → 食べ物モチーフのロボット画像 → 3D生成でロボット で ロボットを戦わせるゲームを作りたいです
- 食べ物の画像 → 食べ物モチーフのロボット画像: NanoBananaを使って食べ物モチーフのロボット画像生成してください
  - プロンプト: この画像をモチーフにしたAポーズのロボットを生成してください．背景は単色にしてください こんな感じ
- 食べ物モチーフのロボット画像 → 3D生成でロボット: messyAIで画像からモデル生成，リメッシュ，テクスチャ生成，アニメート（ヒューマノイド）を行なってください
- また，Gemini APIを用いて食べ物からロボットのデータを生成，
  - ロボットパラメータ: HP(カロリー), ATK(タンパク質), DEF(食物繊維)
    - そのままのパラメータを入れるのではなくできるだけゲームバランスがよくなるように一定の範囲に抑える
  - ロボット名
  - ロボットの概要 (特定の企業や組織が作った最新鋭の戦闘ロボットみたいな変にSF設定をつけつつ元の食べ物の特性を引用したい)
- ゲーム
  - ホーム
    - バトル，建造，図鑑 の三つのページに飛べる
  - ロボット建造
    - ドックが2つあって建造過程が見える
  - 図鑑
    - これまで作ったロボットが一覧で見れる
  - バトル
    1. プレイヤーA のロボットを選択
    2. プレイヤーB のロボットを選択 (Player B はPC)
    3. ゲーム開始
      1. Aの手を選ぶ（Grill, Boil, Fry）
        - Grill → Boil → Fry → Grill と３すくみです
      2. Bが自動で選ばれる
      3. おたがいの手を比較して勝ち，負け，あいこ でどちらかが攻撃する
      4. 繰り返してどちらかのHPがなくなったら負け


食べ物の画像から3Dロボットを生成し、戦わせるというアイデア、非常にユニークでワクワクしますね！
お送りいただいたUIのワイヤーフレームと要件をもとに、「フードファイトロボッツ」のシステム仕様を詳細化しました。

技術スタックとして挙げられている **Tauri + Rust (バックエンド) × Next.js + Three.js (フロントエンド)** は、ローカルでのファイル管理（生成した3Dモデルの保存など）とリッチな3D描画を両立させる上でベストな選択です。特にThree.jsは `@react-three/fiber` などを組み合わせるとNext.jsとの相性も抜群です。

UIと各画面のフロー、そして裏側のAPI連携の詳細な仕様を以下にまとめました。

---

### 1. システム・アーキテクチャ設計

* **フロントエンド (Next.js + TailwindCSS + React Three Fiber)**
* UIの描画、3Dモデル（`.glb`）のレンダリング、アニメーション制御（待機、攻撃、ダメージモーション）。


* **バックエンド (Tauri / Rust)**
* **API連携ハブ:** Gemini API、Nano Banana API、Meshy APIへのリクエストを非同期で処理（Rustの `reqwest` などを利用）。
* **ローカルDB:** SQLite（`rusqlite` 等）を用いて、生成したロボットのステータスやファイルパスをローカルに保存。
* **ファイルシステム:** Meshyから取得した `.glb` ファイルや、Nano Bananaの画像をローカルの特定ディレクトリに保存。



### 2. データ構造 (Robot スキーマ)

Gemini APIを使って、食べ物の栄養素からゲームバランスを崩さないように正規化（スケーリング）します。

* **ID:** UUID
* **名前 (Name):** Geminiが生成した名前（例: 「重装甲麺機 ウドン・ブレイカー」）
* **概要 (Lore):** 企業名やSF設定を交えたフレーバーテキスト
* **HP (カロリーベース):** `(元のカロリー値 / 最大想定カロリー) * 1000 + 基礎値` などで計算（500〜2000の範囲に収める）
* **ATK (タンパク質ベース):** タンパク質量から算出（10〜100の範囲）
* **DEF (食物繊維ベース):** 食物繊維量から算出（5〜50の範囲）
* **ImagePath:** ローカルに保存されたロボット画像のパス
* **ModelPath:** ローカルに保存された `.glb`（3Dモデル）のパス

### 3. 各画面の詳細仕様とパイプライン

#### ① ホーム画面 (Home)

* **機能:** 「Battle」「Construction」「Encyclopedia」へのルーティング。
* **UI/BGM:** サイバーパンクやSF要素がありつつも、少しポップで可愛い要素（Kawaii Future BassのようなBGMやUIデザイン）を入れると、食べ物モチーフという親しみやすさとマッチしそうです。

#### ② 建造画面 (Construction)

お送りいただいた画像の右上にあたる、このゲームのコアとなる部分です。

* **UI:** 2つのドック。空きドックには画像をドラッグ＆ドロップ可能。
* **生成パイプライン (バックエンドで順次実行):**
1. **[Gemini API] ステータス・設定生成:**
* プロンプト例: 「この画像は唐揚げです。カロリー、タンパク質、食物繊維の推定値から、ゲーム用のHP(500-2000), ATK(10-100), DEF(5-50)を算出してください。また、架空の兵器開発企業『オイシイ・インダストリー』が開発した最新鋭ロボットという設定で、唐揚げの特性（油はね、衣の硬さなど）を活かした概要テキストとロボット名を生成してください。出力はJSONで。」


2. **[Nano Banana API] 画像生成:**
* プロンプト: 「この食べ物（画像）をモチーフにした、メカニカルな戦闘ロボットを生成してください。完全なAポーズ（両腕を少し開き、直立した状態）で、背景は無地の単色（例: #FFFFFF）にしてください。」
* ※Meshyの精度を上げるため、Nano Bananaの高忠実度な生成力を活かし、影の少ないフラットなライティングを指定すると良いです。


3. **[Meshy AI API] 3D生成＆リギング:**
* Image to 3Dのエンドポイントに画像を送信。
* オプションで「ヒューマノイド自動リギング（Auto-rigging）」を有効化。
* ポーリング（またはWebhook）で完了を待ち、`.glb` ファイルをダウンロードしてTauriのローカルディレクトリに保存。




* **進捗表示:** Meshyの生成には数分かかるため、Progressバーで「画像解析中」→「設計図作成中」→「3Dプリント＆組み上げ中」といった演出を入れます。

#### ③ 図鑑画面 (Encyclopedia)

* **UI:** グリッド状にこれまで作成したロボットのアイコン（Nano Bananaの画像）を一覧表示。（画像左下）
* **詳細ビュー:** クリックすると、Three.jsの `OrbitControls` を使って3Dモデルをグリグリ回せるプレビュー画面が開き、Geminiが考えたSF設定テキストとパラメータが表示されます。

#### ④ バトル画面 (Battle)

画像右下にある三すくみ（Grill/Boil/Fry）を用いたコマンドバトルです。

* **フロー:**
1. 自機と敵機（CPU）を選出。3Dモデルが対峙する形で画面に描画される。
2. ターンの開始。「Grill (焼く)」「Boil (茹でる)」「Fry (揚げる)」からコマンドを選択。


* **三すくみの判定:**
* `Grill` は `Boil` に勝つ（水分を飛ばす）
* `Boil` は `Fry` に勝つ（油を落とす）
* `Fry` は `Grill` に勝つ（高温で揚げる）


* **ダメージ計算例:**
* **勝ち:** `(ATK - DEF/2) * 1.5`（1.5倍ダメージ） + 攻撃モーション再生
* **あいこ:** 互いに `(ATK - DEF) * 0.5` のダメージ + ぶつかり合いモーション
* **負け:** 攻撃失敗、被弾モーション再生


* **アニメーション:** Meshy AIで自動生成されたボーン構造（Mixamo互換など）を利用し、React Three Fiber上で攻撃（Punch）やダメージ（Hit）のAnimationClipをブレンドして再生します。

---

まずはバックエンド（Rust）側で、画像を投げて「Geminiで設定JSON」と「Nano BananaでAポーズ画像」を取得する部分のロジックから作り始めると、開発のテンポが作りやすいかと思います。

次のステップとして、私がRust側のAPI連携（例えばMeshy AIのタスク作成とポーリングの非同期処理）のコードの土台を書くか、あるいはGemini APIに渡すための「ステータス＆SF設定出力用プロンプト」を最適化して組み上げることもできますが、どちらから進めましょうか？

食べ物の画像から3Dロボットを生成し、戦わせるというアイデア、非常にユニークでワクワクしますね！
お送りいただいたUIのワイヤーフレームと要件をもとに、「フードファイトロボッツ」のシステム仕様を詳細化しました。

技術スタックとして挙げられている **Tauri + Rust (バックエンド) × Next.js + Three.js (フロントエンド)** は、ローカルでのファイル管理（生成した3Dモデルの保存など）とリッチな3D描画を両立させる上でベストな選択です。特にThree.jsは `@react-three/fiber` などを組み合わせるとNext.jsとの相性も抜群です。

UIと各画面のフロー、そして裏側のAPI連携の詳細な仕様を以下にまとめました。

---

### 1. システム・アーキテクチャ設計

* **フロントエンド (Next.js + TailwindCSS + React Three Fiber)**
* UIの描画、3Dモデル（`.glb`）のレンダリング、アニメーション制御（待機、攻撃、ダメージモーション）。


* **バックエンド (Tauri / Rust)**
* **API連携ハブ:** Gemini API、Nano Banana API、Meshy APIへのリクエストを非同期で処理（Rustの `reqwest` などを利用）。
* **ローカルDB:** SQLite（`rusqlite` 等）を用いて、生成したロボットのステータスやファイルパスをローカルに保存。
* **ファイルシステム:** Meshyから取得した `.glb` ファイルや、Nano Bananaの画像をローカルの特定ディレクトリに保存。



### 2. データ構造 (Robot スキーマ)

Gemini APIを使って、食べ物の栄養素からゲームバランスを崩さないように正規化（スケーリング）します。

* **ID:** UUID
* **名前 (Name):** Geminiが生成した名前（例: 「重装甲麺機 ウドン・ブレイカー」）
* **概要 (Lore):** 企業名やSF設定を交えたフレーバーテキスト
* **HP (カロリーベース):** `(元のカロリー値 / 最大想定カロリー) * 1000 + 基礎値` などで計算（500〜2000の範囲に収める）
* **ATK (タンパク質ベース):** タンパク質量から算出（10〜100の範囲）
* **DEF (食物繊維ベース):** 食物繊維量から算出（5〜50の範囲）
* **ImagePath:** ローカルに保存されたロボット画像のパス
* **ModelPath:** ローカルに保存された `.glb`（3Dモデル）のパス

### 3. 各画面の詳細仕様とパイプライン

#### ① ホーム画面 (Home)

* **機能:** 「Battle」「Construction」「Encyclopedia」へのルーティング。
* **UI/BGM:** サイバーパンクやSF要素がありつつも、少しポップで可愛い要素（Kawaii Future BassのようなBGMやUIデザイン）を入れると、食べ物モチーフという親しみやすさとマッチしそうです。

#### ② 建造画面 (Construction)

お送りいただいた画像の右上にあたる、このゲームのコアとなる部分です。

* **UI:** 2つのドック。空きドックには画像をドラッグ＆ドロップ可能。
* **生成パイプライン (バックエンドで順次実行):**
1. **[Gemini API] ステータス・設定生成:**
* プロンプト例: 「この画像は唐揚げです。カロリー、タンパク質、食物繊維の推定値から、ゲーム用のHP(500-2000), ATK(10-100), DEF(5-50)を算出してください。また、架空の兵器開発企業『オイシイ・インダストリー』が開発した最新鋭ロボットという設定で、唐揚げの特性（油はね、衣の硬さなど）を活かした概要テキストとロボット名を生成してください。出力はJSONで。」


2. **[Nano Banana API] 画像生成:**
* プロンプト: 「この食べ物（画像）をモチーフにした、メカニカルな戦闘ロボットを生成してください。完全なAポーズ（両腕を少し開き、直立した状態）で、背景は無地の単色（例: #FFFFFF）にしてください。」
* ※Meshyの精度を上げるため、Nano Bananaの高忠実度な生成力を活かし、影の少ないフラットなライティングを指定すると良いです。


3. **[Meshy AI API] 3D生成＆リギング:**
* Image to 3Dのエンドポイントに画像を送信。
* オプションで「ヒューマノイド自動リギング（Auto-rigging）」を有効化。
* ポーリング（またはWebhook）で完了を待ち、`.glb` ファイルをダウンロードしてTauriのローカルディレクトリに保存。




* **進捗表示:** Meshyの生成には数分かかるため、Progressバーで「画像解析中」→「設計図作成中」→「3Dプリント＆組み上げ中」といった演出を入れます。

#### ③ 図鑑画面 (Encyclopedia)

* **UI:** グリッド状にこれまで作成したロボットのアイコン（Nano Bananaの画像）を一覧表示。（画像左下）
* **詳細ビュー:** クリックすると、Three.jsの `OrbitControls` を使って3Dモデルをグリグリ回せるプレビュー画面が開き、Geminiが考えたSF設定テキストとパラメータが表示されます。

#### ④ バトル画面 (Battle)

画像右下にある三すくみ（Grill/Boil/Fry）を用いたコマンドバトルです。

* **フロー:**
1. 自機と敵機（CPU）を選出。3Dモデルが対峙する形で画面に描画される。
2. ターンの開始。「Grill (焼く)」「Boil (茹でる)」「Fry (揚げる)」からコマンドを選択。


* **三すくみの判定:**
* `Grill` は `Boil` に勝つ（水分を飛ばす）
* `Boil` は `Fry` に勝つ（油を落とす）
* `Fry` は `Grill` に勝つ（高温で揚げる）


* **ダメージ計算例:**
* **勝ち:** `(ATK - DEF/2) * 1.5`（1.5倍ダメージ） + 攻撃モーション再生
* **あいこ:** 互いに `(ATK - DEF) * 0.5` のダメージ + ぶつかり合いモーション
* **負け:** 攻撃失敗、被弾モーション再生


* **アニメーション:** Meshy AIで自動生成されたボーン構造（Mixamo互換など）を利用し、React Three Fiber上で攻撃（Punch）やダメージ（Hit）のAnimationClipをブレンドして再生します。

---

まずはバックエンド（Rust）側で、画像を投げて「Geminiで設定JSON」と「Nano BananaでAポーズ画像」を取得する部分のロジックから作り始めると、開発のテンポが作りやすいかと思います。

次のステップとして、私がRust側のAPI連携（例えばMeshy AIのタスク作成とポーリングの非同期処理）のコードの土台を書くか、あるいはGemini APIに渡すための「ステータス＆SF設定出力用プロンプト」を最適化して組み上げることもできますが、どちらから進めましょうか？

実装に向けて、バックエンド（Rust）から叩くことになる3つの主要なAPI（Geminiによるステータス生成、画像生成、Meshy AIによる3D化）のドキュメント仕様と、ターミナルで検証するための `cURL` コマンドを整理しました。

Tauri + Rustのバックエンドで `reqwest` クレートを使って実装する前の、動作確認用としてお使いください。

---

### 1. Gemini API (ステータス・設定のJSON生成)

食べ物の画像を読み込み、ゲームバランスを考慮したパラメータとSF設定を**JSON形式**で確実に出力させるためのAPIです。`responseMimeType: "application/json"` を指定することで、プログラムでパースしやすい（Markdownブロックなどが混ざらない）純粋なJSONを得られます。

* **エンドポイント:** `POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent`
* **cURLによるテスト:**
※画像のBase64文字列は非常に長いため、適当な短い文字列でテストするか、スクリプトから実行してください。

```bash
curl "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$GEMINI_API_KEY" \
-H 'Content-Type: application/json' \
-X POST \
-d '{
  "contents": [{
    "parts": [
      {"text": "この食べ物画像のカロリー、タンパク質、食物繊維を推定し、HP(500-2000), ATK(10-100), DEF(5-50)を算出し、架空の企業が作った設定の概要(Lore)とロボット名(Name)を考えてJSONで出力してください。"},
      {
        "inlineData": {
          "mimeType": "image/jpeg",
          "data": "<BASE64_ENCODED_IMAGE_DATA>"
        }
      }
    ]
  }],
  "generationConfig": {
    "responseMimeType": "application/json"
  }
}'

```

### 2. 画像生成API (ロボット画像の生成)

高忠実度な画像を生成するAPI（一般向けにはGoogleのImagen 3モデルなどが該当します）を使用し、Meshyに渡すためのAポーズのロボット画像を生成します。

* **エンドポイント:** `POST https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-001:predict`
* **cURLによるテスト:**

```bash
curl "https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-001:predict?key=$GEMINI_API_KEY" \
-H 'Content-Type: application/json' \
-X POST \
-d '{
  "instances": [
    {
      "prompt": "この食べ物をモチーフにしたメカニカルな戦闘ロボット。完全なAポーズで、背景は無地の白単色にしてください。"
    }
  ],
  "parameters": {
    "sampleCount": 1
  }
}'

```

*※注: 実際のワークフローでは、ここで生成された画像データをRust側で一時ファイルとして保存するか、そのままMeshy APIに流し込みます。*

---

### 3. Meshy AI API (3D生成・リギング)

Meshy AIは処理に数分かかるため、**「タスクの作成（POST）」** と **「進捗の確認（GET）」** の2ステップに分かれた非同期APIになっています。

#### ステップ1: タスクの作成 (POST)

生成したロボット画像のURL（またはBase64データ）を渡し、3D化とリギングをリクエストします。

* **エンドポイント:** `POST https://api.meshy.ai/v1/image-to-3d`
* **cURLによるテスト:**

```bash
curl -X POST "https://api.meshy.ai/v1/image-to-3d" \
-H "Authorization: Bearer $MESHY_API_KEY" \
-H "Content-Type: application/json" \
-d '{
  "image_url": "https://example.com/generated_robot_image.png",
  "enable_pbr": true,
  "should_rig": true
}'

```

* **レスポンス例:** `{"result": "task_123456789"}` (このタスクIDを記録します)

#### ステップ2: ポーリングとダウンロード (GET)

Rust側で数秒〜十数秒おきにこのAPIを叩き、ステータスを確認します。

* **エンドポイント:** `GET https://api.meshy.ai/v1/image-to-3d/<TASK_ID>`
* **cURLによるテスト:**

```bash
curl -X GET "https://api.meshy.ai/v1/image-to-3d/<TASK_ID>" \
-H "Authorization: Bearer $MESHY_API_KEY"

```

* **ステータスの遷移:** `PENDING` → `IN_PROGRESS` → `SUCCEEDED`
* `SUCCEEDED` になると、レスポンス内の `model_urls.glb` に `.glb` ファイルのダウンロードURLが含まれるので、それをRustでダウンロードしてローカル（Tauriのデータディレクトリなど）に保存します。

---

### 実装に向けたTips

* **Meshyの画像受け渡し:** Meshy APIの `image_url` は、インターネット上からアクセスできるURLを想定しています。ローカルの画像を処理させる場合は、Base64エンコードで送信できる仕様があるか確認するか、一時的にAWS S3やCloudflare R2などの軽量なオブジェクトストレージに画像をアップロードする処理をRustに挟む必要があります。

まずはターミナルでお手持ちの画像を使って、これらのAPIが期待通りのJSONや画像を返してくるかテストしてみるのが確実です。
Rust (reqwest) でこれらのAPIを繋ぎ合わせる、非同期処理のベースコードを作成しましょうか？

実装を進める上で、公式ドキュメントのリファレンスは必須ですね。今回使用する各APIの公式ドキュメントのリンクをまとめました。

Rust（`reqwest`）からこれらのAPIを叩く際、リクエストのヘッダーやボディの厳密な仕様を確認するためにご活用ください。

### 1. Gemini API（ステータス・設定テキスト生成）

食べ物の画像からJSON形式でパラメータ（HP, ATK, DEF）や設定テキスト（Lore）を生成するためのドキュメントです。

* **公式ドキュメント:** [Google AI for Developers - Gemini API Docs](https://ai.google.dev/docs)
* **APIリファレンス:** [Gemini API Reference](https://ai.google.dev/api)
* **確認すべきポイント:** `generateContent` エンドポイントの使用方法と、JSONのスキーマを固定して出力させる「Structured Outputs（構造化出力）」の項目をご確認ください。画像（マルチモーダル）とテキストを同時に送信する方法もここに記載されています。

### 2. Gemini Gen Media API（画像生成 / Nano Bananaモデル）

私（Gemini）の画像生成は「Nano Banana」という高忠実度なモデルを利用していますが、API経由でこの画像生成機能を利用する場合も、Google AI for Developersの提供するエンドポイントを使用します。

* **公式ドキュメント:** [Google AI for Developers - Image Generation](https://www.google.com/search?q=https://ai.google.dev/docs/image_generation)
* **確認すべきポイント:** プロンプトによる画像生成（Text-to-Image）のエンドポイント仕様。Meshy AIに渡すための「Aポーズで背景が単色のロボット画像」を生成するにあたり、アスペクト比や出力フォーマット（Base64かURLか）の指定方法を確認してください。

### 3. Meshy AI API（3Dモデル生成・リギング）

生成したロボット画像から、ヒューマノイドのボーン（リギング）を含んだ `.glb` モデルを生成するためのドキュメントです。

* **公式ドキュメント:** [Meshy AI API Documentation](https://docs.meshy.ai/)
* **APIリファレンス:** ドキュメント内の `API Reference` セクション
* **確認すべきポイント:** `Image to 3D` のPOSTリクエスト仕様と、その後のGETリクエストによる「タスクのポーリング（進捗確認）」仕様です。また、リギングを自動化するための `should_rig: true`（または相当するパラメータ）の指定方法も重要になります。

---

まずはこれらのAPIのいずれかのテスト呼び出しをRustコードとして実装してみますか？もしよろしければ、`reqwest` と `tokio` を用いたTauriバックエンドのひな形コードを作成することも可能です。