# フードファイトロボッツ 実装計画 (plans.md)

本ドキュメントは、「要件定義とか.md」および「UI.drawio.png」で定義された要件に基づき、「フードファイトロボッツ」の実装ステップを3つのフェーズに分けて詳細に計画したものです。
技術スタックは **Tauri + Rust (バックエンド) × Next.js + Three.js (フロントエンド)** を想定しています。

## 1. 技術検証 (Technical Verification)
このフェーズでは、本プロジェクトのコアとなる各種生成AI APIの連携を確立し、プロトタイプとして「簡易的な図鑑機能」が動作する状態を目指します。

### 1-1. Gemini API (ステータス・設定テキスト生成の検証)
- **目的**: 食べ物の画像から、ゲームバランスを考慮したステータス (HP, ATK, DEF) とロボットの概要 (Lore)、名前 (Name) をJSON形式で安定して取得する。
- **実装ステップ**:
  - Rustバックエンドから `reqwest` を用いて、Gemini API (`gemini-2.5-flash` など) にマルチモーダルリクエスト（画像データ＋プロンプト）を送信するロジックを実装。
  - `responseMimeType: "application/json"` を指定し、パース可能な構造化データとして結果を受け取る。
  - バックエンドでパースしたJSONデータをフロントエンド (Next.js) へ Tauri コマンド経由で返す検証を実施する。

### 1-2. Gemini API (NanoBananaによる画像生成の検証)
- **目的**: 食べ物の画像から、Meshy AIでの3D化に適した「Aポーズで単色背景」のロボット画像を生成する。
- **実装ステップ**:
  - 適切な画像生成モデル (Imagen 3等、指定のNanoBananaモデル) の API に対して元画像とプロンプトを送信する。
  - 生成された画像データをRustバックエンドでローカルディレクトリ環境 (OSのAppData等) に保存するファイルシステム関連の処理を実装する。

### 1-3. Meshy AI API (3D生成＆リギングの検証)
- **目的**: 1-2で生成したロボット画像から、ヒューマノイド自動リギング済みの3Dモデル (`.glb`) を生成し、取得する。
- **実装ステップ**:
  - Meshyの `Image to 3D` (POST) へ画像データを送信してタスクを作成し、Tauri側でTask IDを保持。
  - タスクの完了を待つポーリング処理 (GET連携) を非同期に実装し、ステータスが `SUCCEEDED` となった時点の `.glb` ダウンロードURLを取得。
  - ダウンロード処理を実行して `.glb` ファイルをローカルファイルシステムに安全に保存する。

### 1-4. 簡易的な図鑑機能の作成 (マイルストーン1)
- **目的**: 1-1〜1-3のパイプラインを一貫して実行し、生成した全データをローカルDBに保存し、一覧・詳細表示できるUIを作成する。
- **実装ステップ**:
  - **DB構築**: TauriでSQLite (`rusqlite` 等) をセットアップし、「Robot」テーブル (UUID, Name, Lore, HP, ATK, DEF, ImagePath, ModelPath) を設計・作成。
  - **フロントUI**: 単純なファイルアップローダーを用意し、画像を投げるUIを作成。
  - 全APIが順番に処理された後、生成された画像(`ImagePath`)と、名前等を表示する「グリッド一覧画面（図鑑プレビュー）」を作る。
  - 詳細表示で `@react-three/fiber` の `OrbitControls` を実装し、ローカルに保存された `.glb` モデルをブラウザ上で回転・拡大プレビューできるか確認する。

---

## 2. UIの一通りの実装 (Full UI Implementation)
Next.js と TailwindCSS を用いて、ワイヤーフレーム (UI.drawio.png) に沿った4画面 (Home, Construction, Encyclopedia, Battle) のレイアウトや画面遷移を実装します。

### 2-1. ホーム画面 (Home)
- **実装ステップ**:
  - 「Battle」「Construction」「Encyclopedia」の3つのリンクボタンを配置し、ルーティングを構築。
  - アプリケーション全体のテーマコンセプト (世界観に合わせたSF調＋ポップなテイスト) やカラーパレット、CSSシステムを構築する。

### 2-2. 建造画面 (Construction)
- **実装ステップ**:
  - 2つの建造ドックを示すレイアウト構築。
  - 「Drop FoodImage」と表示された領域へのドラッグ＆ドロップインターフェイスの実装。
  - API処理中のフィードバックとして、もう一方のドックに「Under construction」と進捗状況を示すProgressバー UIの実装。
  - Tauri側の進捗イベント（Event emit）をNext.js側でリッスンしてUIに反映する仕組みの構築。

### 2-3. 図鑑画面 (Encyclopedia) の正規化
- **実装ステップ**:
  - フェーズ1の簡易的な図鑑UIを洗練させる。
  - サムネイル画像 (生成された二次元ロボット画像) とロボット名が並ぶグリッドレイアウトのスタイリング。
  - アイコンクリック時の画面遷移または詳細モーダル表示にステータス（HP, ATK, DEF）と設定文 (Lore) を綺麗にオーバーレイ配置する。

### 2-4. バトル画面 (Battle) のガワ(UIレイアウト)作成
- **実装ステップ**:
  - 画面の左右または手前・奥に「自機」と「敵機」のステータス領域 (HPバー、名前、属性など) を配置する。
  - 中央下部に「Grill」「Boil」「Fry」の3つのコマンドをワイヤーフレームの図に沿った円形または三角形のUIで配置する。
  - クリック時の状態管理やコマンド発火用の空関数を準備。具体的な3D描画箇所は `<Canvas>` 領域としてプレースホルダーを空けておく。

---

## 3. インゲームの3D実装 (In-game 3D Implementation)
React Three Fiber (`@react-three/fiber`) と Drei (`@react-three/drei`) を本格的に活用し、バトル画面での臨場感ある3D描画とゲームロジックを作ります。

### 3-1. 3Dバトルステージの構築
- **実装ステップ**:
  - React Three Fiber `<Canvas>` でメインのバトル領域を作成。
  - ライティング設定 (DirectionalLight, AmbientLight等) や、バトルアリーナのような背景空間 (Environmentマップ等) を設定。
  - 選択された「自機」と「敵機」の `.glb` モデル（ローカルパス）をそれぞれ適切なスケール・位置で向かい合わせるようにロードし、配置する (`useGLTF`)。

### 3-2. アニメーション制御
- **実装ステップ**:
  - Meshy AIで付与された自動リギング骨格(Mixamo互換等のヒューマノイドベース)に対して、`THREE.AnimationMixer` や Drei の `<useAnimations>` フックを用いてアニメーションを制御。
  - それぞれのモデルに対して、「待機 (Idle)」「攻撃 (Punch / Attack)」「被弾 (Damage / Hit)」などの基礎的なアニメーションクリップを読み込み、状態に合わせてスムーズにブレンド切り替えするロジックを実装。

### 3-3. 三すくみ・バトルロジックと演出の統合
- **実装ステップ**:
  - コマンド（Grill > Boil > Fry > Grill）の三すくみ判定ロジックの実装。
  - プレイヤーのコマンド入力後、CPUの手を決定。
  - 判定結果に基づき、勝者が「攻撃モーション」、敗者が「被弾モーション」を再生するタイムライン/イベントの制御。
  - 各機のステータス (ATK, DEF) を元にしたダメージ計算処理の実装と、UIのHPバー減少アニメーションの同期。
  - HPが0になった際の「敗北 / 破壊モーション（倒れるなど）」の再生。
  - パーティクルエフェクトやカメラワーク (`camera.lookAt` 等) の追加調整によるバトルのリッチ化・完成。
